#!/bin/sh

# open cluster management (ocm) hub and managed minikube kvm amd64 clusters deploy
# https://github.com/ShyamsundarR/ocm-minikube/README.md

set -x
set -e
trap 'echo exit value: $?' EXIT

#minikube delete -p hub
#minikube delete -p cluster1

mkdir -p ${HOME}/.local/bin
PATH=${HOME}/.local/bin:${PATH}

# curl not installed?
if ! command -v curl; then
	cd ${HOME}/.local/bin
	wget -O curl https://github.com/moparisthebest/static-curl/releases/download/v7.76.0/curl-amd64
	chmod +x curl
	cd -
fi

# minikube not installed?
if ! command -v minikube; then
	# https://minikube.sigs.k8s.io/docs/start/
	# minikube-linux-amd64 download and install
	cd ${HOME}/.local/bin
	minikube_version=latest
	minikube_version=v1.18.1
	curl -Lo minikube https://storage.googleapis.com/minikube/releases/${minikube_version}/minikube-linux-amd64
	unset -v minikube_version
	chmod +x minikube
	cd -
fi

minikube_start_options=--driver=kvm2
. /etc/os-release # NAME

# kvm not installed?
if false; then
	# https://minikube.sigs.k8s.io/docs/drivers/kvm2/
	case ${NAME} in
	"Red Hat Enterprise Linux Server")
		# https://access.redhat.com/articles/1344173#Q_how-install-virtualization-packages
		sudo yum install libvirt -y
		;;
	"Ubuntu")
		# https://help.ubuntu.com/community/KVM/Installation
		sudo apt-get update
		if true || test ${VERSION_ID} -ge "18.10"; then
			sudo apt-get install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils -y
		else
			sudo apt-get install qemu-kvm libvirt-bin ubuntu-vm-builder bridge-utils -y
		fi
		;;
	esac
	sudo usermod -aG libvirt ${LOGNAME}
	# groups refresh
	exec su - ${LOGNAME}
fi

# ocm hub cluster deploy
minikube start ${minikube_start_options} --profile=hub --cpus=4

# kubectl not installed?
# TODO or less than version 1.11 (wait unsupported)
if ! command -v kubectl; then
	# https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/#install-kubectl-binary-with-curl-on-linux
	cd ${HOME}/.local/bin
	curl -LO https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl
	chmod +x kubectl
	cd -
fi

if ! command -v kustomize; then
	cd ${HOME}/.local/bin
	curl -L https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv4.0.5/kustomize_v4.0.5_linux_amd64.tar.gz | tar -xz
	cd -
fi

kubectl apply -f https://raw.githubusercontent.com/kubernetes/cluster-registry/master/cluster-registry-crd.yaml
set +e
git clone https://github.com/open-cluster-management/registration-operator
git clone https://github.com/ShyamsundarR/ocm-minikube
set -e
# registration-operator make deploy-hub requires go version 1.14.4 or greater
	# https://golang.org/ref/mod#versions
	# https://semver.org/spec/v2.0.0.html
case ${NAME} in
"Ubuntu")
	deploy_arguments=GO_REQUIRED_MIN_VERSION:=
	;;
esac
# go not installed?
# TODO or version less than 1.14.4?
if ! command -v go
#|| $(go version | { read _ _ v _; echo ${v#go}; })
then
	PATH=${HOME}/.local/go/bin:${PATH}
	if ! command -v go; then
		cd ${HOME}/.local
		curl -L https://golang.org/dl/go1.16.2.linux-amd64.tar.gz | tar -xz
		cd -
	fi
fi
cd ./registration-operator
git checkout release-2.3
# managed cluster names other than cluster1 require
set +e
git apply ../ocm-minikube/registration-operator.diff
set -e
set +e
make deploy-hub ${deploy_arguments}
set -e
cd ../
date
kubectl --context hub -n olm                     wait deployments --all --for condition=available --timeout 1m
date
kubectl --context hub -n open-cluster-management wait deployments --all --for condition=available
# https://github.com/kubernetes/kubernetes/issues/83242
i=0; while
! kubectl --context hub -n open-cluster-management-hub get deployments/cluster-manager-registration-controller --ignore-not-found=false >/dev/null 2>&1 ||\
! kubectl --context hub -n open-cluster-management-hub get deployments/cluster-manager-registration-webhook    --ignore-not-found=false >/dev/null 2>&1 ||\
! kubectl --context hub -n open-cluster-management-hub get deployments/cluster-manager-work-webhook            --ignore-not-found=false >/dev/null 2>&1 &&\
test $i -lt 90; do sleep 1; i=$((i+1)); done; unset -v i
date
kubectl --context hub -n open-cluster-management-hub wait deployments --all --for condition=available --timeout 2m
date

# managed cluster1 deploy
minikube start ${minikube_start_options} --profile=cluster1
unset -v minikube_start_options

kubectl --context hub config view --flatten --minify >/tmp/hub-config

spoke_add()
{
	cluster_name=${1}
	cd ./registration-operator
	export MANAGED_CLUSTER=${cluster_name}
	#export KUBECONFIG=/tmp/hub-config
	export HUB_KUBECONFIG=/tmp/hub-config
	kubectl config use-context ${cluster_name}
	set +e
	make deploy-spoke ${deploy_arguments}
	set -e
	cd ../

	kubectl --context ${cluster_name} -n open-cluster-management wait deployments --all --for condition=available
	date
	# https://github.com/kubernetes/kubernetes/issues/83242
	i=0; while
	! kubectl --context ${cluster_name} -n open-cluster-management-agent get deployments/klusterlet-registration-agent --ignore-not-found=false >/dev/null 2>&1 \
	&& test $i -lt 60; do sleep 1; i=$((i+1)); done; unset -v i
	#! kubectl --context ${cluster_name} -n open-cluster-management-agent get deployments/klusterlet-work-agent         -oname  >/dev/null 2>&1 &&\
	kubectl --context ${cluster_name} -n open-cluster-management-agent wait deployments/klusterlet-registration-agent --for condition=available

	# hub register managed cluster
	set +e
	kubectl --context hub certificate approve $(kubectl --context hub get csr --field-selector spec.signerName=kubernetes.io/kube-apiserver-client --selector open-cluster-management.io/cluster-name=${cluster_name} -oname)
	set -e
	#kubectl wait csr ${csr_name} --for condition=approved
	kubectl --context hub patch managedcluster ${cluster_name} -p='{"spec":{"hubAcceptsClient":true}}' --type=merge
	kubectl --context hub wait managedcluster/${cluster_name} --for condition=ManagedClusterConditionAvailable
	kubectl --context ${cluster_name} -n open-cluster-management-agent wait deployments --all --for condition=available

	# test
	sed -e "s,KIND_CLUSTER,${cluster_name}," -i ./ocm-minikube/examples/kustomization.yaml
	set +e
	kubectl --context hub apply -k ./ocm-minikube/examples/
	set -e
	sed -e "s,${cluster_name},KIND_CLUSTER," -i ./ocm-minikube/examples/kustomization.yaml
	unset -v cluster_name
}
spoke_add cluster1

# hub subscription operator
set +e
git clone https://github.com/open-cluster-management/multicloud-operators-subscription
set -e
cd ./multicloud-operators-subscription
set +e
git apply ../ocm-minikube/multicloud-operators-subscription.diff
set -e
kubectl config use-context hub
USE_VENDORIZED_BUILD_HARNESS=faked make deploy-community-hub
cd ../

kubectl --context hub -n multicluster-operators wait deployments --all --for condition=available --timeout 2m

spoke_add_hub()
{
	spoke_add ${1}
	kubectl --context hub patch managedcluster ${1} -p='{"metadata":{"labels":{"local-cluster":"true"}}}' --type=merge
}
spoke_add_hub hub
unset -v deploy_arguments

# hub managed cluster subscription operator
export MANAGED_CLUSTER_NAME=hub
# kubectl config use-context hub
cd multicloud-operators-subscription
export HUB_KUBECONFIG=/tmp/hub-config
cp -f ${HUB_KUBECONFIG} /tmp/kubeconfig
set +e
kubectl --context hub -n multicluster-operators create secret generic appmgr-hub-kubeconfig --from-file=kubeconfig=/tmp/kubeconfig
set -e
mkdir -p munge-manifests
cp deploy/managed/operator.yaml munge-manifests/operator.yaml
sed -i 's/<managed cluster name>/'"$MANAGED_CLUSTER_NAME"'/g' munge-manifests/operator.yaml
sed -i 's/<managed cluster namespace>/'"$MANAGED_CLUSTER_NAME"'/g' munge-manifests/operator.yaml
sed -i '0,/name: multicluster-operators-subscription/{s/name: multicluster-operators-subscription/name: multicluster-operators-subscription-mc/}' munge-manifests/operator.yaml
kubectl --context hub apply -f munge-manifests/operator.yaml
kubectl --context hub -n multicluster-operators wait deployments --all --for condition=available

cluster_name=cluster1
# managed cluster subscription operator
# export HUB_KUBECONFIG=/tmp/hub-config
kubectl config use-context ${cluster_name}
export MANAGED_CLUSTER_NAME=${cluster_name}
USE_VENDORIZED_BUILD_HARNESS=faked make deploy-community-managed
kubectl --context ${cluster_name} -n multicluster-operators wait deployments --all --for condition=available

# test
kubectl --context hub apply -f examples/helmrepo-hub-channel
kubectl --context ${cluster_name} wait deployments --all --for condition=available
cd ..

#
kubectl --context hub patch managedcluster ${cluster_name} -p='{"metadata":{"labels":{"usage":"test"}}}' --type=merge
set +e
git clone https://github.com/open-cluster-management/application-samples
set -e
cd application-samples
set +e
git apply ../ocm-minikube/application-samples.diff
set -e
kubectl --context hub apply -k subscriptions/channel
set +e
# Error from server (InternalError): error when creating "subscriptions/book-import": Internal error occurred: failed calling webhook "applications.apps.open-cluster-management.webhook": Post "https://multicluster-operators-application-svc.multicluster-operators.svc:443/app-validate?timeout=10s": dial tcp 10.106.210.84:443: connect: connection refused
kubectl --context hub apply -k subscriptions/book-import
# Error from server (InternalError): error when creating "subscriptions/book-import/application.yaml": Internal error occurred: failed calling webhook "applications.apps.open-cluster-management.webhook": Post "https://multicluster-operators-application-svc.multicluster-operators.svc:443/app-validate?timeout=10s": dial tcp 10.106.210.84:443: connect: connection refused
kubectl --context hub apply -f subscriptions/book-import/application.yaml 
set -e
# https://github.com/kubernetes/kubernetes/issues/83242
i=0; while ! kubectl --context ${cluster_name} -n book-import get deployments --ignore-not-found=false >/dev/null 2>&1 && test $i -lt 30; do sleep 1; i=$((i+1)); done; unset -v i
kubectl --context ${cluster_name} -n book-import wait deployments --all --for condition=available
unset -v cluster_name
