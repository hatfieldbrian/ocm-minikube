#!/bin/sh

# open cluster management (ocm) hub and managed minikube kvm amd64 clusters deploy
# https://github.com/ShyamsundarR/ocm-minikube/README.md

set -x
set -e
trap 'echo "return value: $?"' EXIT

mkdir -p ${HOME}/.local/bin
PATH=${HOME}/.local/bin:${PATH}

# curl not installed?
if ! command -v curl; then
	cd ${HOME}/.local/bin
	wget -O curl https://github.com/moparisthebest/static-curl/releases/download/v7.76.0/curl-amd64
	chmod +x curl
	cd -
fi

# minikube not installed?
if ! command -v minikube; then
	# https://minikube.sigs.k8s.io/docs/start/
	# minikube-linux-amd64 download and install
	cd ${HOME}/.local/bin
	curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
	chmod +x minikube
	cd -
fi

minikube_start_options=--driver=kvm2\ --kvm-network=default
. /etc/os-release # NAME

# kvm not installed?
if false; then
	# https://minikube.sigs.k8s.io/docs/drivers/kvm2/
	case ${NAME} in
	"Red Hat Enterprise Linux Server")
		# https://access.redhat.com/articles/1344173#Q_how-install-virtualization-packages
		sudo yum install libvirt -y
		;;
	"Ubuntu")
		# https://help.ubuntu.com/community/KVM/Installation
		sudo apt-get update
		if true || test ${VERSION_ID} -ge "18.10"; then
			sudo apt-get install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils -y
		else
			sudo apt-get install qemu-kvm libvirt-bin ubuntu-vm-builder bridge-utils -y
		fi
		;;
	esac
	sudo usermod -aG libvirt ${LOGNAME}
	# groups refresh
	exec su - ${LOGNAME}
fi

# ocm hub cluster deploy
minikube start ${minikube_start_options} --profile=hub --cpus=4

# kubectl alias (re)define
#alias kubectl=minikube\ kubectl\ --

# kubectl not installed?
# TODO or less than version 1.11 (wait unsupported)
if ! command -v kubectl; then
	# https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/#install-kubectl-binary-with-curl-on-linux
	cd ${HOME}/.local/bin
	curl -LO https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl
	chmod +x kubectl
	cd -
fi

if ! command -v kustomize; then
	cd ${HOME}/.local/bin
	curl -L https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv4.0.5/kustomize_v4.0.5_linux_amd64.tar.gz | tar -xz
	cd -
fi

kubectl apply -f https://raw.githubusercontent.com/kubernetes/cluster-registry/master/cluster-registry-crd.yaml
set +e
git clone https://github.com/open-cluster-management/registration-operator.git
git clone https://github.com/ShyamsundarR/ocm-minikube.git
set -e
# registration-operator make deploy-hub requires go version 1.14.4 or greater
	# https://golang.org/ref/mod#versions
	# https://semver.org/spec/v2.0.0.html
case ${NAME} in
"Ubuntu")
	deploy_arguments=GO_REQUIRED_MIN_VERSION:=
	;;
esac
# go not installed?
# TODO or version less than 1.14.4?
if ! command -v go
#|| $(go version | { read _ _ v _; echo ${v#go}; })
then
	PATH=${HOME}/.local/go/bin:${PATH}
	if ! command -v go; then
		cd ${HOME}/.local
		curl -L https://golang.org/dl/go1.16.2.linux-amd64.tar.gz | tar -xz
		cd -
	fi
fi
cd ./registration-operator
git checkout release-2.3
# TODO managed cluster names other than cluster1 require
#git apply ../ocm-minikube/registration-operator.diff
set +e
make deploy-hub ${deploy_arguments}
set -e
kubectl wait deployments --all --for condition=Available -n olm --timeout 1m
kubectl wait deployments --all --for condition=Available -n open-cluster-management
# https://github.com/kubernetes/kubernetes/issues/83242
i=0; while
! kubectl get deployments -n open-cluster-management-hub --field-selector metadata.name=cluster-manager-registration-controller -ojsonpath={.items[0].status.availableReplicas} 2>/dev/null ||\
! kubectl get deployments -n open-cluster-management-hub --field-selector metadata.name=cluster-manager-registration-webhook    -ojsonpath={.items[0].status.availableReplicas} 2>/dev/null ||\
! kubectl get deployments -n open-cluster-management-hub --field-selector metadata.name=cluster-manager-work-webhook            -ojsonpath={.items[0].status.availableReplicas} 2>/dev/null &&\
test $i -lt 90; do sleep 1; i=$((i+1)); done; unset -v i
kubectl wait deployments --all --for condition=Available -n open-cluster-management-hub --timeout 2m

# managed cluster deploy
minikube start ${minikube_start_options} --profile=cluster1
unset -v minikube_start_options
kubectl config view --flatten --context=hub --minify >/tmp/hub-config
#kubectl config use-context cluster1
#export KLUSTERLET_KIND_KUBECONFIG=/tmp/cluster1-config # TODO remove
#export KIND_CLUSTER=cluster1 # TODO remove
#export MANAGED_CLUSTER=cluster1
#export HUB_KIND_KUBECONFIG=/tmp/hub-config
#export KUBECONFIG=/tmp/hub-config
export HUB_KUBECONFIG=/tmp/hub-config
set +e
make deploy-spoke ${deploy_arguments}
set -e
unset -v deploy_arguments
kubectl config current-context
kubectl wait deployments --all --for condition=Available -n open-cluster-management
date
# https://github.com/kubernetes/kubernetes/issues/83242
i=0; while
! kubectl get deployments -n open-cluster-management-agent --field-selector metadata.name=klusterlet-registration-agent -ojsonpath={.items[0].status.availableReplicas} 2>/dev/null ||\
! kubectl get deployments -n open-cluster-management-agent --field-selector metadata.name=klusterlet-work-agent         -ojsonpath={.items[0].status.availableReplicas} 2>/dev/null &&\
test $i -lt 60; do sleep 1; i=$((i+1)); done; unset -v i
kubectl wait deployments --all --for condition=Available -n open-cluster-management-agent

# hub register managed cluster
kubectl config use-context hub
kubectl wait csr --field-selector spec.signerName=kubernetes.io/kube-apiserver-client --for condition=condition=Pending
kubectl wait csr --field-selector spec.signerName=kubernetes.io/kube-apiserver-client-kubelet --for condition=condition=Approved,Issued
kubectl certificate approve $(kubectl get csr --field-selector spec.signerName=kubernetes.io/kube-apiserver-client -ojsonpath={.items[0].metadata.name})
kubectl wait csr --field-selector spec.signerName=kubernetes.io/kube-apiserver-client --for condition=Approved,Issued
kubectl patch managedcluster cluster1 -p='{"spec":{"hubAcceptsClient":true}}' --type=merge
kubectl wait managedcluster --all --for condition=Available=true

# test
kubectl config use-context hub
sed -e "s,KIND_CLUSTER,$KIND_CLUSTER," -i ../ocm-minikube/examples/kustomization.yaml
kubectl apply -k ../ocm-minikube/examples/
sed -e "s,$KIND_CLUSTER,KIND_CLUSTER," -i ../ocm-minikube/examples/kustomization.yaml

:<<'!'
# hub subscription operator
git clone git@github.com:open-cluster-management/multicloud-operators-subscription.git
cd multicloud-operators-subscription
git apply ../ocm-minikube/multicloud-operators-subscription.diff
kubectl config use-context hub
USE_VENDORIZED_BUILD_HARNESS=faked make deploy-community-hub

# deployments wait
kubectl get deployments -n multicluster-operators

# hub managed cluster subscription operator
kubectl config use-context hub
kubectl get managedcluster hub
export MANAGED_CLUSTER_NAME=hub
kubectl patch managedcluster ${MANAGED_CLUSTER_NAME} -p='{"metadata":{"labels":{"local-cluster":"true"}}}' --type=merge

cd ../multicloud-operators-subscription

export HUB_KUBECONFIG=/tmp/hub-config
cp -f ${HUB_KUBECONFIG} /tmp/kubeconfig
kubectl -n multicluster-operators create secret generic appmgr-hub-kubeconfig --from-file=kubeconfig=/tmp/kubeconfig
mkdir -p munge-manifests
cp deploy/managed/operator.yaml munge-manifests/operator.yaml
sed -i 's/<managed cluster name>/'"$MANAGED_CLUSTER_NAME"'/g' munge-manifests/operator.yaml
sed -i 's/<managed cluster namespace>/'"$MANAGED_CLUSTER_NAME"'/g' munge-manifests/operator.yaml
sed -i '0,/name: multicluster-operators-subscription/{s/name: multicluster-operators-subscription/name: multicluster-operators-subscription-mc/}' munge-manifests/operator.yaml
kubectl apply -f munge-manifests/operator.yaml

# deployments wait
kubectl get deployments -n multicluster-operators

# managed cluster subscription operator
export HUB_KUBECONFIG=/tmp/hub-config
kubectl config use-context cluster1
export MANAGED_CLUSTER_NAME=cluster1
USE_VENDORIZED_BUILD_HARNESS=faked make deploy-community-managed

# deployments wait
kubectl get deployments -n multicluster-operators

# test
kubectl config use-context hub
kubectl apply -f examples/helmrepo-hub-channel
kubectl get pods --context=cluster1

kubectl patch managedcluster cluster1 -p='{"metadata":{"labels":{"usage":"test"}}}' --type=merge
git clone git@github.com:open-cluster-management/application-samples.git
cd application-samples
git apply ../ocm-minikube/application-samples.diff
kubectl apply -k subscriptions/channel
kubectl apply -k subscriptions/book-import
kubectl apply -f subscriptions/book-import/application.yaml 
kubectl get pods --context=cluster1 -n book-import
!

#minikube delete -p cluster1
#minikube delete -p hub
# kubectl alias undefine
#unalias kubectl
